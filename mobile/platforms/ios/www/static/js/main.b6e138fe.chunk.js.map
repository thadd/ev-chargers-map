{"version":3,"sources":["cordova.js","App.js","serviceWorker.js","index.js"],"names":["initialize","config","setTimeout","document","addEventListener","console","log","window","open","cordova","InAppBrowser","getConfigByType","PushRegistration","register","timeout","then","catch","err","error","MOBILE_SERVICES","require","app","init","authService","Auth","CHARGERS_NEAR","gql","FAVORITES","SET_FAVORITE","MARKER_ICON","L","AwesomeMarkers","icon","markerColor","prefix","geocoder","OpenStreetMapProvider","ChargerPopup","props","className","isAuthenticated","onClick","toggleFavorite","id","isFavorite","station_name","access_days_time","ev_network","App","state","map","mapCenter","mapBounds","location","searchedLocation","chargers","favoriteChargers","isAuthLoading","initializeDataService","bind","initializeMap","handleLocationUpdate","handleSearch","handleLogin","handleLogout","handleToggleFavorites","loginComplete","Promise","callback","setState","userProfile","search","query","results","Number","raw","lat","lon","bounds","savedSearch","localStorage","getItem","removeItem","JSON","parse","Event","event","this","target","value","preventDefault","length","center","latitude","longitude","dataClient","variables","fetchPolicy","data","chargersNear","chargerBounds","Math","min","c","max","setItem","stringify","login","logout","chargerId","newFavoritesArray","includes","_","without","mutate","mutation","dataSyncConfig","find","configurations","type","clientOptions","httpUrl","url","wsUrl","websocketUrl","token","extract","authContextProvider","headers","Authorization","OfflineClient","favorites","loadUserProfile","mapOptions","zoom","Fragment","firstName","lastName","onSubmit","onChange","charger","key","Map","whenReady","TileLayer","attribution","Marker","position","Popup","Component","Boolean","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.b6e138fe.chunk.js","sourcesContent":["import { PushRegistration } from \"@aerogear/push\";\n\nfunction initialize(config) {\n  setTimeout(() => {\n    function deviceReady() {\n      console.log('device is ready');\n      window.open = window.cordova.InAppBrowser.open;\n\n      console.log('registering push', config.getConfigByType('push'));\n      (new PushRegistration(config)).register({timeout: 60000}).then(() => {\n          console.log('push registration complete');\n      }).catch(err => {\n          console.error('push reg failed', err);\n      });\n    }\n\n    document.addEventListener(\"deviceready\", deviceReady, false);\n\n    console.log('initialized cordova');\n  }, 10000);\n}\n\nexport {initialize};","import React, { Component } from 'react';\n\nimport L from 'leaflet';\nimport { OpenStreetMapProvider } from 'leaflet-geosearch';\nimport _ from 'lodash';\nimport gql from 'graphql-tag';\nimport { OfflineClient } from '@aerogear/voyager-client';\nimport { Auth } from '@aerogear/auth';\nimport * as Promise from 'bluebird';\n\nimport { Map, Marker, Popup, TileLayer } from 'react-leaflet'\n\nimport 'font-awesome/css/font-awesome.css';\nimport 'leaflet.awesome-markers';\nimport 'leaflet/dist/leaflet.css';\nimport 'leaflet.awesome-markers/dist/leaflet.awesome-markers.css';\n\nimport './App.css';\n\nimport { init } from \"@aerogear/app\";\n\n// Initialize mobile services\nconst MOBILE_SERVICES = require('./mobile-services.json');\nconst app = init(MOBILE_SERVICES);\n\nif (window.cordova) {\n  require('./cordova').initialize(app.config);\n}\n\n// Set up auth service\nconst authService = new Auth(app.config);\n\n// Define GraphQL queries we'll use\nconst CHARGERS_NEAR = gql`\n  query ChargersNear($latitude:Float!, $longitude:Float!) {\n    chargersNear(location:{\n      latitude:$latitude\n      longitude:$longitude\n    }) {\n      id\n      station_name\n      latitude\n      longitude\n      access_days_time\n      ev_network\n    }\n  }\n`;\nconst FAVORITES = gql`\n  query Favorites {\n    favorites {\n      id\n    }\n  }\n`;\nconst SET_FAVORITE = gql`\n  mutation SetFavorite($id:ID!, $isFavorite:Boolean!) {\n    setFavorite(id:$id, isFavorite:$isFavorite) {\n      id\n    }\n  }\n`;\n\n// Set up the map markers\nconst MARKER_ICON = L.AwesomeMarkers.icon({\n  icon: 'bolt',\n  markerColor: 'red',\n  prefix: 'fa',\n});\n\nconst geocoder = new OpenStreetMapProvider();\n\n// Map popup when user clicks a charger\nconst ChargerPopup = props => (\n  <div className='station-popup'>\n    {props.isAuthenticated && (\n      <div className='favorite pull-left' onClick={() => props.toggleFavorite(props.id)}>\n        {!props.isFavorite ? (\n          <div className='fa-stack'>\n            <i className='far fa-star fa-stack-2x'></i>\n          </div>\n        ) : (\n          <div className='fa-stack'>\n            <i className='fas fa-star fa-stack-2x'></i>\n            <i className='far fa-star fa-stack-2x'></i>\n          </div>\n        )}\n      </div>\n     )}\n    <strong>{props.station_name}</strong>\n    <br />\n    <em>{props.access_days_time}</em>\n    <br />{props.ev_network}\n  </div>\n);\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      map: null,\n      mapCenter: null,\n      mapBounds: null,\n      location: '',\n      searchedLocation: [],\n      chargers: [],\n      favoriteChargers: [],\n      isAuthLoading: true,\n      isAuthenticated: false,\n    };\n\n    this.initializeDataService = this.initializeDataService.bind(this);\n    this.initializeMap = this.initializeMap.bind(this);\n    this.handleLocationUpdate = this.handleLocationUpdate.bind(this);\n    this.handleSearch = this.handleSearch.bind(this);\n    this.handleLogin = this.handleLogin.bind(this);\n    this.handleLogout = this.handleLogout.bind(this);\n    this.handleToggleFavorites = this.handleToggleFavorites.bind(this);\n    this.loginComplete = this.loginComplete.bind(this);\n  }\n\n  componentDidMount() {\n    // Initialize the auth service\n    authService.init({})\n    .then(() => {\n      if (authService.isAuthenticated()) {\n        // Load the user profile if we're logged in\n        return this.loginComplete();\n      } else {\n        return Promise.fromCallback(callback => this.setState({\n          userProfile: null,\n          isAuthLoading: false,\n          isAuthenticated: false,\n        }, callback))\n        .then(this.initializeDataService);\n      }\n    })\n    .catch(err => console.error('initialization error', err));\n  }\n\n  initializeMap() {\n    // Default to map of CA\n    geocoder.search({ query: 'California' })\n    .then(results => {\n      this.setState({\n        mapCenter: [Number(results[0].raw.lat), Number(results[0].raw.lon)],\n        mapBounds: results[0].bounds,\n      })\n    })\n    // If we're coming back from login, restore the search\n    .then(() => {\n      let savedSearch = localStorage.getItem('savedSearch');\n\n      if (savedSearch) {\n        localStorage.removeItem('savedSearch');\n\n        this.setState({\n          location: JSON.parse(savedSearch)\n        }, () => {\n          // Execute the search\n          this.handleSearch(new Event('dummy'));\n        });\n      }\n    })\n  }\n\n  handleLocationUpdate(event) {\n    this.setState({\n      location: event.target.value,\n    });\n  }\n\n  handleSearch(event) {\n    event.preventDefault();\n\n    geocoder.search({query: this.state.location})\n    .then(results => {\n      // Ensure we got a resulting location\n      if (results.length >= 1) {\n        this.setState({\n          searchedLocation: results\n        }, () => {\n          // Recenter the map\n          this.setState({mapBounds: results[0].bounds});\n\n          let center = {\n            latitude: Number(results[0].raw.lat),\n            longitude: Number(results[0].raw.lon),\n          };\n\n          this.state.dataClient.query({query: CHARGERS_NEAR, variables: center, fetchPolicy: 'network-only'}).then(({data}) => {\n            let chargers = data.chargersNear;\n\n            // Zoom the map to the markers\n            let chargerBounds = [\n              [\n                Math.min(...chargers.map(c => c.latitude)),\n                Math.min(...chargers.map(c => c.longitude)),\n              ],\n              [\n                Math.max(...chargers.map(c => c.latitude)),\n                Math.max(...chargers.map(c => c.longitude)),\n              ],\n            ];\n\n            this.setState({\n              chargers,\n              mapBounds: chargerBounds,\n            });\n          });\n        })\n      }\n    })\n  }\n\n  handleLogin(event) {\n    this.setState({\n      isAuthLoading: true,\n    });\n\n    // Store the current search field so we can be more seamless when we get back from login\n    if (this.state.location && this.state.location.length > 0) {\n      localStorage.setItem('savedSearch', JSON.stringify(this.state.location));\n    }\n\n    authService.login().then(this.loginComplete)\n  }\n\n  handleLogout(event) {\n    this.setState({\n      isAuthLoading: true,\n    });\n\n    authService.logout().then(() => {\n      this.setState({\n        isAuthenticated: false,\n        isAuthLoading: false,\n      })\n    }, err => {\n      this.setState({\n        isAuthLoading: false,\n      });\n\n      console.error('authService error', err);\n    })\n    .catch(err => {\n      this.setState({\n        isAuthLoading: false,\n      });\n\n      console.error('authService error', err);\n    });\n  }\n\n  handleToggleFavorites(chargerId) {\n    return Promise.fromCallback(callback => {\n      let newFavoritesArray;\n\n      if (this.state.favoriteChargers.includes(chargerId)) {\n        newFavoritesArray = _.without(this.state.favoriteChargers, chargerId);\n      } else {\n        newFavoritesArray = [...(this.state.favoriteChargers), chargerId];\n      }\n\n      this.setState({\n        favoriteChargers: newFavoritesArray,\n      }, callback);\n    })\n    .then(() => (\n      this.state.dataClient.mutate({\n        mutation: SET_FAVORITE,\n        variables: {\n          id: chargerId,\n          isFavorite: this.state.favoriteChargers.includes(chargerId),\n        },\n        fetchPolicy: 'no-cache'\n      })\n    ))\n    .catch(err => console.error('mutation', err));\n  }\n\n  initializeDataService() {\n    // Set up data sync service\n    const dataSyncConfig = _.find(app.config.configurations, {type: 'sync-app'});\n\n    const clientOptions = {\n      // httpUrl: `http://localhost:8080/graphql${authService.isAuthenticated() ? '-auth' : ''}`,\n      // wsUrl: `http://localhost:8080/graphql${authService.isAuthenticated() ? '-auth' : ''}`,\n      httpUrl: `${dataSyncConfig.url}${authService.isAuthenticated() ? '-auth' : ''}`,\n      wsUrl: `${dataSyncConfig.config.websocketUrl}${authService.isAuthenticated() ? '-auth' : ''}`,\n    }\n\n    if (authService.isAuthenticated()) {\n      const token = authService.extract().token;\n      clientOptions.authContextProvider = () => {\n        return {\n          headers: {\n            Authorization: `Bearer ${token}`\n          },\n          token,\n        }\n      };\n    }\n\n    const dataSyncService = new OfflineClient(clientOptions);\n\n    return dataSyncService.init()\n    .then(dataClient => Promise.fromCallback(callback => this.setState({dataClient}, callback)))\n    .then(() => {\n      if (authService.isAuthenticated()) {\n        console.log('authenticated, fetching chargers');\n        return this.state.dataClient.query({query: FAVORITES, fetchPolicy: 'network-only'})\n        .then(({data}) => {\n          console.log('data', data); this.setState({favoriteChargers: _.map(data.favorites, 'id')})}, console.error);\n      }\n    })\n    .catch(err => console.error('data sync initialization rejection', err));\n  }\n\n  loginComplete() {\n    return authService.loadUserProfile()\n    .then(userProfile => Promise.fromCallback(callback => (\n      this.setState({\n        isAuthenticated: authService.isAuthenticated(),\n        isAuthLoading: false,\n        userProfile,\n      }, callback)\n    )))\n    .then(this.initializeDataService)\n    .then(() => console.log('initialization complete'))\n    .catch(err => {\n      this.setState({\n        isAuthLoading: false,\n      });\n\n      console.error('authService error', err);\n    })\n  }\n\n  render() {\n\n    let mapCenter = this.state.mapCenter ? this.state.mapCenter : [36.7014631, -118.7559974];\n\n    let mapOptions = {\n      zoom: this.state.mapBounds ? null : 13,\n      bounds: this.state.mapBounds,\n    };\n\n    return (\n      <div className='root'>\n        <div id='actions'>\n          <div className='profile'>\n            {this.state.isAuthLoading ? (\n              <div className='text-center'>\n                <i className='fas fa-circle-notch fa-spin'></i>\n              </div>\n            ) : (\n              this.state.isAuthenticated ? (\n                <React.Fragment>\n                  <span>Welcome, {this.state.userProfile.firstName} {this.state.userProfile.lastName}!</span>\n                  <button className='btn btn-secondary btn-sm pull-right' onClick={() => this.handleLogout()}><i className='fa fa-user' /> Log out</button>\n                </React.Fragment>\n              ) : (\n                <div className='text-center'>\n                  <button className='btn btn-secondary btn-sm' onClick={() => this.handleLogin()}><i className='fa fa-user' /> Log in</button>\n                </div>\n              )\n            )}\n          </div>\n\n          <form onSubmit={this.handleSearch}>\n            <div className='form-group'>\n              <div className='input-group'>\n                <input className='form-control' type='text' value={this.state.location} onChange={this.handleLocationUpdate} />\n                <div className='input-group-append'>\n                  <button className='btn btn-primary' type='submit'><i className='fa fa-search' /></button>\n                </div>\n              </div>\n            </div>\n          </form>\n\n          <div className='charger-list'>\n            {this.state.chargers.map(charger => (\n              <div key={charger.id} className={`card charger ${this.state.favoriteChargers.includes(charger.id) ? 'favorite' : ''}`}>\n                <div className='card-body'>\n                  <h5 className='card-title'>{charger.station_name}</h5>\n                  <p className='card-text'>\n                    {charger.access_days_time}\n                  </p>\n                </div>\n              </div>\n            ))}\n          </div>\n        </div>\n        {this.state.dataClient && (\n          <div id='map-container'>\n            <div id='map'>\n              <Map id='map' center={mapCenter} {...mapOptions} whenReady={this.initializeMap}>\n                <TileLayer\n                  url='https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'\n                  attribution='&copy; <a href=&quot;http://osm.org/copyright&quot;>OpenStreetMap</a> contributors'\n                />\n\n                {this.state.chargers.map(charger => (\n                  <Marker key={charger.id} position={[charger.latitude, charger.longitude]} icon={MARKER_ICON}>\n                    <Popup>\n                      <ChargerPopup\n                        {...charger}\n                        isAuthenticated={this.state.isAuthenticated}\n                        isFavorite={this.state.favoriteChargers.includes(charger.id)}\n                        toggleFavorite={this.handleToggleFavorites}\n                        />\n                    </Popup>\n                  </Marker>\n                ))}\n              </Map>\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}